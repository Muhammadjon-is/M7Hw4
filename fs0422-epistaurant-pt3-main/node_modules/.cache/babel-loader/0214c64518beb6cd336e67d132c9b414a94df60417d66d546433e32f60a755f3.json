{"ast":null,"code":"var _jsxFileName = \"/home/isakov/Desktop/ReactEpicode/M7Hw4/fs0422-epistaurant-pt3-main/src/components/ReservationList.jsx\";\n// this will be a component capable of fetching live data in its mounting process\n// for understanding this, we have to focus once again on the connection\n// we have to establish between the interface of the component and its state (its logic)\n\n// STEPS HAPPENING:\n// 1) INITIAL RENDER() INVOKATION: this will output to the page the static parts,\n// like the <h2> tag or the shell for the empyty ListGroup (empty since the state\n// is still empty at this moment, [])\n// 2) because we wrote a componentDidMount, that is what happens next, since\n// COMPONENTDIDMOUNT FIRES AFTER THE INITIAL RENDER() INVOKATION;\n// componentDidMount fetches the data (it's perfect for doing expensive operations),\n// and sets the state just once (you're guaranteed of that)\n// 3) because a setState just happened in the componentDidMount, RENDER() (who\n// is always listening for state changes) detects it and FIRES AGAIN! will now\n// leave in place the static parts, since there's no need to rewrite them, but\n// when it's time to map the array for generating the list, since now we have\n// filled our state with reservations, will generate the new elements of the list.\n\nimport { Component } from 'react';\nimport { ListGroup, Spinner, Alert } from 'react-bootstrap';\nimport { parseISO, format } from 'date-fns';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass ReservationList extends Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      reservations: [],\n      isLoading: true,\n      isError: false\n    };\n    this.fetchReservations = async () => {\n      try {\n        let response = await fetch('https://striveschool-api.herokuapp.com/api/reservation');\n        if (response.ok) {\n          // everything looks ok :)\n          let data = await response.json();\n          // console.log(data)\n          // data is the array of reservations we're getting back from the API\n          this.setState({\n            reservations: data,\n            isLoading: false\n          });\n        } else {\n          console.log('error fetching the reservations :(');\n          // server reached, but it encountered a problem with our request\n          setTimeout(() => {\n            this.setState({\n              isLoading: false,\n              isError: true\n            });\n          }, 1000);\n        }\n      } catch (error) {\n        console.log(error);\n        // this error happens when you're not able at all to reach the server...\n        // (internet problem?)\n        this.setState({\n          isLoading: false,\n          isError: true\n        });\n      }\n    };\n  }\n  componentDidMount() {\n    console.log('COMPONENTDIDMOUNT FIRED!');\n    // componentDidMount is another lifecycle method, but it's guaranteed\n    // to be executed JUST ONCE :)\n    // it is designed to launch fetches, expensive operations to fill your\n    // initial state with dynamic data, and never being called again.\n    // ONE-SHOT METHOD.\n    this.fetchReservations();\n\n    // COMPONENT DID MOUNT HAPPENS AFTER INITIAL RENDER() INVOKATION!\n  }\n\n  // just a test method, if launched from render() crashes the application\n  // since setting the state calls render() again --> INFINITE LOOP\n  //   thisWillCrash = () => {\n  //     this.setState({\n  //       reservations: [],\n  //     })\n  //   }\n\n  // render() is a lifecycle method!\n  // render() is in charge of outputting the JSX from the component\n  // render() is invoked when the component mounts, and it's invoked AGAIN\n  // every time there's a change in the STATE of the component or the PROPS\n  // the component is receiving\n  render() {\n    // this.fetchReservations()\n    // PLEASE, DON'T SET YOUR STATE FROM RENDER()!\n    // this.thisWillCrash()\n\n    console.log('RENDER FIRED!');\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"RESERVATIONS LIST\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 105,\n        columnNumber: 9\n      }, this), this.state.isLoading && /*#__PURE__*/_jsxDEV(Spinner, {\n        animation: \"border\",\n        role: \"status\",\n        className: \"custom-spinner-color\",\n        children: /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"sr-only\",\n          children: \"Loading...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 117,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 112,\n        columnNumber: 11\n      }, this)\n      //   JSX IS ALWAYS A TRUTHY VALUE, SO WHAT YOU'RE REALLY CHECKING\n      // IS THE TRUTHINESS OF YOUR CONDITION\n      , /*#__PURE__*/_jsxDEV(ListGroup, {\n        className: \"mt-4\",\n        children: [this.state.reservations.map(r => /*#__PURE__*/_jsxDEV(ListGroup.Item, {\n          children: [r.name, \" for \", r.numberOfPeople, \" people at\", ' ', format(parseISO(r.dateTime), 'MMMM do yyyy - HH:mm')]\n        }, r._id, true, {\n          fileName: _jsxFileName,\n          lineNumber: 128,\n          columnNumber: 13\n        }, this)\n        // we'd like to convert r.dateTime, which is an ugly timestamp,\n        // to a proper formatted date. We're going to use 2 methods from date-fns:\n        // 1) parseISO takes the ugly timestamp and creates a Date object for it,\n        // pointing to a moment in time\n        // 2) format instead takes a Date object, and returns a string in the\n        // format you like\n        ), this.state.isError && /*#__PURE__*/_jsxDEV(Alert, {\n          variant: \"danger\",\n          children: \"Whoopsie, something went wrong! :(\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 140,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 122,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 7\n    }, this);\n  }\n}\nexport default ReservationList;","map":{"version":3,"names":["Component","ListGroup","Spinner","Alert","parseISO","format","ReservationList","state","reservations","isLoading","isError","fetchReservations","response","fetch","ok","data","json","setState","console","log","setTimeout","error","componentDidMount","render","map","r","name","numberOfPeople","dateTime","_id"],"sources":["/home/isakov/Desktop/ReactEpicode/M7Hw4/fs0422-epistaurant-pt3-main/src/components/ReservationList.jsx"],"sourcesContent":["// this will be a component capable of fetching live data in its mounting process\r\n// for understanding this, we have to focus once again on the connection\r\n// we have to establish between the interface of the component and its state (its logic)\r\n\r\n// STEPS HAPPENING:\r\n// 1) INITIAL RENDER() INVOKATION: this will output to the page the static parts,\r\n// like the <h2> tag or the shell for the empyty ListGroup (empty since the state\r\n// is still empty at this moment, [])\r\n// 2) because we wrote a componentDidMount, that is what happens next, since\r\n// COMPONENTDIDMOUNT FIRES AFTER THE INITIAL RENDER() INVOKATION;\r\n// componentDidMount fetches the data (it's perfect for doing expensive operations),\r\n// and sets the state just once (you're guaranteed of that)\r\n// 3) because a setState just happened in the componentDidMount, RENDER() (who\r\n// is always listening for state changes) detects it and FIRES AGAIN! will now\r\n// leave in place the static parts, since there's no need to rewrite them, but\r\n// when it's time to map the array for generating the list, since now we have\r\n// filled our state with reservations, will generate the new elements of the list.\r\n\r\nimport { Component } from 'react'\r\nimport { ListGroup, Spinner, Alert } from 'react-bootstrap'\r\nimport { parseISO, format } from 'date-fns'\r\n\r\nclass ReservationList extends Component {\r\n  // very common situation: you want to fill the interface of a component\r\n  // at load time, and show the user the results of your fetch\r\n\r\n  // every time you need to fetch data upon component loading, you need\r\n  // a place to store it! you'll use the COMPONENT STATE for this!\r\n\r\n  state = {\r\n    reservations: [],\r\n    isLoading: true,\r\n    isError: false,\r\n  }\r\n\r\n  fetchReservations = async () => {\r\n    try {\r\n      let response = await fetch(\r\n        'https://striveschool-api.herokuapp.com/api/reservation'\r\n      )\r\n      if (response.ok) {\r\n        // everything looks ok :)\r\n        let data = await response.json()\r\n        // console.log(data)\r\n        // data is the array of reservations we're getting back from the API\r\n        this.setState({\r\n          reservations: data,\r\n          isLoading: false,\r\n        })\r\n      } else {\r\n        console.log('error fetching the reservations :(')\r\n        // server reached, but it encountered a problem with our request\r\n        setTimeout(() => {\r\n          this.setState({\r\n            isLoading: false,\r\n            isError: true,\r\n          })\r\n        }, 1000)\r\n      }\r\n    } catch (error) {\r\n      console.log(error)\r\n      // this error happens when you're not able at all to reach the server...\r\n      // (internet problem?)\r\n      this.setState({\r\n        isLoading: false,\r\n        isError: true,\r\n      })\r\n    }\r\n  }\r\n\r\n  componentDidMount() {\r\n    console.log('COMPONENTDIDMOUNT FIRED!')\r\n    // componentDidMount is another lifecycle method, but it's guaranteed\r\n    // to be executed JUST ONCE :)\r\n    // it is designed to launch fetches, expensive operations to fill your\r\n    // initial state with dynamic data, and never being called again.\r\n    // ONE-SHOT METHOD.\r\n    this.fetchReservations()\r\n\r\n    // COMPONENT DID MOUNT HAPPENS AFTER INITIAL RENDER() INVOKATION!\r\n  }\r\n\r\n  // just a test method, if launched from render() crashes the application\r\n  // since setting the state calls render() again --> INFINITE LOOP\r\n  //   thisWillCrash = () => {\r\n  //     this.setState({\r\n  //       reservations: [],\r\n  //     })\r\n  //   }\r\n\r\n  // render() is a lifecycle method!\r\n  // render() is in charge of outputting the JSX from the component\r\n  // render() is invoked when the component mounts, and it's invoked AGAIN\r\n  // every time there's a change in the STATE of the component or the PROPS\r\n  // the component is receiving\r\n  render() {\r\n    // this.fetchReservations()\r\n    // PLEASE, DON'T SET YOUR STATE FROM RENDER()!\r\n    // this.thisWillCrash()\r\n\r\n    console.log('RENDER FIRED!')\r\n\r\n    return (\r\n      <div>\r\n        <h2>RESERVATIONS LIST</h2>\r\n        {/* we should find a way to hide the spinner once the loading process\r\n        has finished... */}\r\n\r\n        {/* LET'S CREATE A CONDITIONAL RENDERING FOR THE SPINNER */}\r\n        {/* && is called a SHORT CIRCUIT operator */}\r\n        {this.state.isLoading && (\r\n          <Spinner\r\n            animation=\"border\"\r\n            role=\"status\"\r\n            className=\"custom-spinner-color\"\r\n          >\r\n            <span className=\"sr-only\">Loading...</span>\r\n          </Spinner>\r\n          //   JSX IS ALWAYS A TRUTHY VALUE, SO WHAT YOU'RE REALLY CHECKING\r\n          // IS THE TRUTHINESS OF YOUR CONDITION\r\n        )}\r\n        <ListGroup className=\"mt-4\">\r\n          {/* <ListGroup.Item>Hello World!</ListGroup.Item> */}\r\n          {/* Let's create the connection between the interface and the state! */}\r\n          {/* In this way, for updating the list we won't have to manipulate the DOM, */}\r\n          {/* we'll just have to keep the state up-to-date */}\r\n          {this.state.reservations.map((r) => (\r\n            <ListGroup.Item key={r._id}>\r\n              {r.name} for {r.numberOfPeople} people at{' '}\r\n              {format(parseISO(r.dateTime), 'MMMM do yyyy - HH:mm')}\r\n            </ListGroup.Item>\r\n            // we'd like to convert r.dateTime, which is an ugly timestamp,\r\n            // to a proper formatted date. We're going to use 2 methods from date-fns:\r\n            // 1) parseISO takes the ugly timestamp and creates a Date object for it,\r\n            // pointing to a moment in time\r\n            // 2) format instead takes a Date object, and returns a string in the\r\n            // format you like\r\n          ))}\r\n          {this.state.isError && (\r\n            <Alert variant=\"danger\">Whoopsie, something went wrong! :(</Alert>\r\n          )}\r\n        </ListGroup>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default ReservationList\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}